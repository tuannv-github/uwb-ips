'''
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: protocol.xml

Note: this file has been auto-generated. DO NOT EDIT
'''
from __future__ import print_function
from builtins import range
from builtins import object
import struct, array, time, json, os, sys, platform

from pymavlink.generator.mavcrc import x25crc
import hashlib

WIRE_PROTOCOL_VERSION = '1.0'
DIALECT = 'mavlink'

PROTOCOL_MARKER_V1 = 0xFE
PROTOCOL_MARKER_V2 = 0xFD
HEADER_LEN_V1 = 6
HEADER_LEN_V2 = 10

MAVLINK_SIGNATURE_BLOCK_LEN = 13

MAVLINK_IFLAG_SIGNED = 0x01

native_supported = platform.system() != 'Windows' # Not yet supported on other dialects
native_force = 'MAVNATIVE_FORCE' in os.environ # Will force use of native code regardless of what client app wants
native_testing = 'MAVNATIVE_TESTING' in os.environ # Will force both native and legacy code to be used and their results compared

if native_supported and float(WIRE_PROTOCOL_VERSION) <= 1:
    try:
        import mavnative
    except ImportError:
        print('ERROR LOADING MAVNATIVE - falling back to python implementation')
        native_supported = False
else:
    # mavnative isn't supported for MAVLink2 yet
    native_supported = False

# some base types from mavlink_types.h
MAVLINK_TYPE_CHAR     = 0
MAVLINK_TYPE_UINT8_T  = 1
MAVLINK_TYPE_INT8_T   = 2
MAVLINK_TYPE_UINT16_T = 3
MAVLINK_TYPE_INT16_T  = 4
MAVLINK_TYPE_UINT32_T = 5
MAVLINK_TYPE_INT32_T  = 6
MAVLINK_TYPE_UINT64_T = 7
MAVLINK_TYPE_INT64_T  = 8
MAVLINK_TYPE_FLOAT    = 9
MAVLINK_TYPE_DOUBLE   = 10


class MAVLink_header(object):
    '''MAVLink message header'''
    def __init__(self, msgId, incompat_flags=0, compat_flags=0, mlen=0, seq=0, srcSystem=0, srcComponent=0):
        self.mlen = mlen
        self.seq = seq
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.msgId = msgId
        self.incompat_flags = incompat_flags
        self.compat_flags = compat_flags

    def pack(self, force_mavlink1=False):
        if WIRE_PROTOCOL_VERSION == '2.0' and not force_mavlink1:
            return struct.pack('<BBBBBBBHB', 254, self.mlen,
                               self.incompat_flags, self.compat_flags,
                               self.seq, self.srcSystem, self.srcComponent,
                               self.msgId&0xFFFF, self.msgId>>16)
        return struct.pack('<BBBBBB', PROTOCOL_MARKER_V1, self.mlen, self.seq,
                           self.srcSystem, self.srcComponent, self.msgId)

class MAVLink_message(object):
    '''base MAVLink message class'''
    def __init__(self, msgId, name):
        self._header     = MAVLink_header(msgId)
        self._payload    = None
        self._msgbuf     = None
        self._crc        = None
        self._fieldnames = []
        self._type       = name
        self._signed     = False
        self._link_id    = None
        self._instances  = None
        self._instance_field = None

    # swiped from DFReader.py
    def to_string(self, s):
        '''desperate attempt to convert a string regardless of what garbage we get'''
        try:
            return s.decode("utf-8")
        except Exception as e:
            pass
        try:
            s2 = s.encode('utf-8', 'ignore')
            x = u"%s" % s2
            return s2
        except Exception:
            pass
        # so its a nasty one. Let's grab as many characters as we can
        r = ''
        while s != '':
            try:
                r2 = r + s[0]
                s = s[1:]
                r2 = r2.encode('ascii', 'ignore')
                x = u"%s" % r2
                r = r2
            except Exception:
                break
        return r + '_XXX'

    def format_attr(self, field):
        '''override field getter'''
        raw_attr = getattr(self,field)
        if isinstance(raw_attr, bytes):
            raw_attr = self.to_string(raw_attr).rstrip("\00")
        return raw_attr

    def get_msgbuf(self):
        if isinstance(self._msgbuf, bytearray):
            return self._msgbuf
        return bytearray(self._msgbuf)

    def get_header(self):
        return self._header

    def get_payload(self):
        return self._payload

    def get_crc(self):
        return self._crc

    def get_fieldnames(self):
        return self._fieldnames

    def get_type(self):
        return self._type

    def get_msgId(self):
        return self._header.msgId

    def get_srcSystem(self):
        return self._header.srcSystem

    def get_srcComponent(self):
        return self._header.srcComponent

    def get_seq(self):
        return self._header.seq

    def get_signed(self):
        return self._signed

    def get_link_id(self):
        return self._link_id

    def __str__(self):
        ret = '%s {' % self._type
        for a in self._fieldnames:
            v = self.format_attr(a)
            ret += '%s : %s, ' % (a, v)
        ret = ret[0:-2] + '}'
        return ret

    def __ne__(self, other):
        return not self.__eq__(other)

    def __eq__(self, other):
        if other is None:
            return False

        if self.get_type() != other.get_type():
            return False

        # We do not compare CRC because native code doesn't provide it
        #if self.get_crc() != other.get_crc():
        #    return False

        if self.get_seq() != other.get_seq():
            return False

        if self.get_srcSystem() != other.get_srcSystem():
            return False

        if self.get_srcComponent() != other.get_srcComponent():
            return False

        for a in self._fieldnames:
            if self.format_attr(a) != other.format_attr(a):
                return False

        return True

    def to_dict(self):
        d = dict({})
        d['mavpackettype'] = self._type
        for a in self._fieldnames:
          d[a] = self.format_attr(a)
        return d

    def to_json(self):
        return json.dumps(self.to_dict())

    def sign_packet(self, mav):
        h = hashlib.new('sha256')
        self._msgbuf += struct.pack('<BQ', mav.signing.link_id, mav.signing.timestamp)[:7]
        h.update(mav.signing.secret_key)
        h.update(self._msgbuf)
        sig = h.digest()[:6]
        self._msgbuf += sig
        mav.signing.timestamp += 1

    def pack(self, mav, crc_extra, payload, force_mavlink1=False):
        plen = len(payload)
        if WIRE_PROTOCOL_VERSION != '1.0' and not force_mavlink1:
            # in MAVLink2 we can strip trailing zeros off payloads. This allows for simple
            # variable length arrays and smaller packets
            nullbyte = chr(0)
            # in Python2, type("fred') is str but also type("fred")==bytes
            if str(type(payload)) == "<class 'bytes'>":
                nullbyte = 0
            while plen > 1 and payload[plen-1] == nullbyte:
                plen -= 1
        self._payload = payload[:plen]
        incompat_flags = 0
        if mav.signing.sign_outgoing:
            incompat_flags |= MAVLINK_IFLAG_SIGNED
        self._header  = MAVLink_header(self._header.msgId,
                                       incompat_flags=incompat_flags, compat_flags=0,
                                       mlen=len(self._payload), seq=mav.seq,
                                       srcSystem=mav.srcSystem, srcComponent=mav.srcComponent)
        self._msgbuf = self._header.pack(force_mavlink1=force_mavlink1) + self._payload
        crc = x25crc(self._msgbuf[1:])
        if True: # using CRC extra
            crc.accumulate_str(struct.pack('B', crc_extra))
        self._crc = crc.crc
        self._msgbuf += struct.pack('<H', self._crc)
        if mav.signing.sign_outgoing and not force_mavlink1:
            self.sign_packet(mav)
        return self._msgbuf

    def __getitem__(self, key):
        '''support indexing, allowing for multi-instance sensors in one message'''
        if self._instances is None:
            raise IndexError()
        if not key in self._instances:
            raise IndexError()
        return self._instances[key]


# enums

class EnumEntry(object):
    def __init__(self, name, description):
        self.name = name
        self.description = description
        self.param = {}

enums = {}

# resond_t
enums['resond_t'] = {}
RESPOND_OK = 1 # 
enums['resond_t'][1] = EnumEntry('RESPOND_OK', '''''')
RESPOND_ERROR = 2 # 
enums['resond_t'][2] = EnumEntry('RESPOND_ERROR', '''''')
resond_t_ENUM_END = 3 # 
enums['resond_t'][3] = EnumEntry('resond_t_ENUM_END', '''''')

# rmode_t
enums['rmode_t'] = {}
MODE_RUN = 1 # 
enums['rmode_t'][1] = EnumEntry('MODE_RUN', '''''')
MODE_HW = 2 # 
enums['rmode_t'][2] = EnumEntry('MODE_HW', '''''')
MODE_IMU = 3 # 
enums['rmode_t'][3] = EnumEntry('MODE_IMU', '''''')
MODE_PIDT_TW = 4 # 
enums['rmode_t'][4] = EnumEntry('MODE_PIDT_TW', '''''')
MODE_PIDT_TA = 5 # 
enums['rmode_t'][5] = EnumEntry('MODE_PIDT_TA', '''''')
rmode_t_ENUM_END = 6 # 
enums['rmode_t'][6] = EnumEntry('rmode_t_ENUM_END', '''''')

# cmd_t
enums['cmd_t'] = {}
CMD_SAVE = 1 # 
enums['cmd_t'][1] = EnumEntry('CMD_SAVE', '''''')
CMD_LOAD = 2 # 
enums['cmd_t'][2] = EnumEntry('CMD_LOAD', '''''')
cmd_t_ENUM_END = 3 # 
enums['cmd_t'][3] = EnumEntry('cmd_t_ENUM_END', '''''')

# sensor_t
enums['sensor_t'] = {}
SENSOR_IMU_OK = 1 # 
enums['sensor_t'][1] = EnumEntry('SENSOR_IMU_OK', '''''')
SENSOR_IMU_ERROR = 2 # 
enums['sensor_t'][2] = EnumEntry('SENSOR_IMU_ERROR', '''''')
sensor_t_ENUM_END = 3 # 
enums['sensor_t'][3] = EnumEntry('sensor_t_ENUM_END', '''''')

# bool_t
enums['bool_t'] = {}
MAV_FALSE = 1 # 
enums['bool_t'][1] = EnumEntry('MAV_FALSE', '''''')
MAV_TRUE = 2 # 
enums['bool_t'][2] = EnumEntry('MAV_TRUE', '''''')
bool_t_ENUM_END = 3 # 
enums['bool_t'][3] = EnumEntry('bool_t_ENUM_END', '''''')

# pidc_t
enums['pidc_t'] = {}
PID_TILT = 1 # 
enums['pidc_t'][1] = EnumEntry('PID_TILT', '''''')
PID_VEL = 2 # 
enums['pidc_t'][2] = EnumEntry('PID_VEL', '''''')
PID_POS = 3 # 
enums['pidc_t'][3] = EnumEntry('PID_POS', '''''')
PID_WHE0 = 4 # 
enums['pidc_t'][4] = EnumEntry('PID_WHE0', '''''')
PID_WHE1 = 5 # 
enums['pidc_t'][5] = EnumEntry('PID_WHE1', '''''')
PID_WHE2 = 6 # 
enums['pidc_t'][6] = EnumEntry('PID_WHE2', '''''')
PID_WHE3 = 7 # 
enums['pidc_t'][7] = EnumEntry('PID_WHE3', '''''')
PID_SYNC = 8 # 
enums['pidc_t'][8] = EnumEntry('PID_SYNC', '''''')
pidc_t_ENUM_END = 9 # 
enums['pidc_t'][9] = EnumEntry('pidc_t_ENUM_END', '''''')

# tilt_type_t
enums['tilt_type_t'] = {}
ROLL = 1 # 
enums['tilt_type_t'][1] = EnumEntry('ROLL', '''''')
PITCH = 2 # 
enums['tilt_type_t'][2] = EnumEntry('PITCH', '''''')
tilt_type_t_ENUM_END = 3 # 
enums['tilt_type_t'][3] = EnumEntry('tilt_type_t_ENUM_END', '''''')

# role_t
enums['role_t'] = {}
ANCHOR = 1 # 
enums['role_t'][1] = EnumEntry('ANCHOR', '''''')
TAG = 2 # 
enums['role_t'][2] = EnumEntry('TAG', '''''')
role_t_ENUM_END = 3 # 
enums['role_t'][3] = EnumEntry('role_t_ENUM_END', '''''')

# message IDs
MAVLINK_MSG_ID_BAD_DATA = -1
MAVLINK_MSG_ID_RESPOND = 0
MAVLINK_MSG_ID_CMD_CHANGE_MODE = 1
MAVLINK_MSG_ID_CMD_PARAMS = 2
MAVLINK_MSG_ID_CMD_VELOCITY = 3
MAVLINK_MSG_ID_EVT_TILT = 4
MAVLINK_MSG_ID_EVT_RPY = 5
MAVLINK_MSG_ID_EVT_SENSOR = 6
MAVLINK_MSG_ID_MOTOR_SPEED = 7
MAVLINK_MSG_ID_HW_PARAMS = 8
MAVLINK_MSG_ID_GYRO_PARAMS = 9
MAVLINK_MSG_ID_COMP_FILTER_PARAMS = 10
MAVLINK_MSG_ID_EVT_ACCEL_RAW = 11
MAVLINK_MSG_ID_EVT_GYRO_RAW = 12
MAVLINK_MSG_ID_EVT_CALIBRATED_GYRO_RAW = 13
MAVLINK_MSG_ID_EVT_MAG_RAW = 14
MAVLINK_MSG_ID_PID_PARAMS = 15
MAVLINK_MSG_ID_PID_REPORT = 16
MAVLINK_MSG_ID_BLINK = 17
MAVLINK_MSG_ID_BLE_MESH = 18
MAVLINK_MSG_ID_ONOFF = 19
MAVLINK_MSG_ID_LOCATION = 20
MAVLINK_MSG_ID_LOCATION_REDUCED = 21
MAVLINK_MSG_ID_DISTANCE = 22
MAVLINK_MSG_ID_TOF = 23
MAVLINK_MSG_ID_SLOT = 24
MAVLINK_MSG_ID_TAG = 25

class MAVLink_respond_message(MAVLink_message):
        '''
        Respond for a reliable communication
        '''
        id = MAVLINK_MSG_ID_RESPOND
        name = 'RESPOND'
        fieldnames = ['respond']
        ordered_fieldnames = ['respond']
        fieldtypes = ['uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"respond": "resond_t"}
        fieldunits_by_name = {}
        format = '<B'
        native_format = bytearray('<B', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 164
        unpacker = struct.Struct('<B')
        instance_field = None
        instance_offset = -1

        def __init__(self, respond):
                MAVLink_message.__init__(self, MAVLink_respond_message.id, MAVLink_respond_message.name)
                self._fieldnames = MAVLink_respond_message.fieldnames
                self._instance_field = MAVLink_respond_message.instance_field
                self._instance_offset = MAVLink_respond_message.instance_offset
                self.respond = respond

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 164, struct.pack('<B', self.respond), force_mavlink1=force_mavlink1)

class MAVLink_cmd_change_mode_message(MAVLink_message):
        '''
        Command Change Mode. Need a respond message for confimation
        '''
        id = MAVLINK_MSG_ID_CMD_CHANGE_MODE
        name = 'CMD_CHANGE_MODE'
        fieldnames = ['cmd_change_mode']
        ordered_fieldnames = ['cmd_change_mode']
        fieldtypes = ['uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"cmd_change_mode": "rmode_t"}
        fieldunits_by_name = {}
        format = '<B'
        native_format = bytearray('<B', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 44
        unpacker = struct.Struct('<B')
        instance_field = None
        instance_offset = -1

        def __init__(self, cmd_change_mode):
                MAVLink_message.__init__(self, MAVLink_cmd_change_mode_message.id, MAVLink_cmd_change_mode_message.name)
                self._fieldnames = MAVLink_cmd_change_mode_message.fieldnames
                self._instance_field = MAVLink_cmd_change_mode_message.instance_field
                self._instance_offset = MAVLink_cmd_change_mode_message.instance_offset
                self.cmd_change_mode = cmd_change_mode

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 44, struct.pack('<B', self.cmd_change_mode), force_mavlink1=force_mavlink1)

class MAVLink_cmd_params_message(MAVLink_message):
        '''
        Save Or Load Params
        '''
        id = MAVLINK_MSG_ID_CMD_PARAMS
        name = 'CMD_PARAMS'
        fieldnames = ['cmd_params']
        ordered_fieldnames = ['cmd_params']
        fieldtypes = ['int8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"cmd_params": "cmd_params_t"}
        fieldunits_by_name = {}
        format = '<b'
        native_format = bytearray('<b', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 245
        unpacker = struct.Struct('<b')
        instance_field = None
        instance_offset = -1

        def __init__(self, cmd_params):
                MAVLink_message.__init__(self, MAVLink_cmd_params_message.id, MAVLink_cmd_params_message.name)
                self._fieldnames = MAVLink_cmd_params_message.fieldnames
                self._instance_field = MAVLink_cmd_params_message.instance_field
                self._instance_offset = MAVLink_cmd_params_message.instance_offset
                self.cmd_params = cmd_params

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 245, struct.pack('<b', self.cmd_params), force_mavlink1=force_mavlink1)

class MAVLink_cmd_velocity_message(MAVLink_message):
        '''
        Velocity command. No need a respond message for confimation
        '''
        id = MAVLINK_MSG_ID_CMD_VELOCITY
        name = 'CMD_VELOCITY'
        fieldnames = ['v', 'omega']
        ordered_fieldnames = ['v', 'omega']
        fieldtypes = ['float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<ff'
        native_format = bytearray('<ff', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 202
        unpacker = struct.Struct('<ff')
        instance_field = None
        instance_offset = -1

        def __init__(self, v, omega):
                MAVLink_message.__init__(self, MAVLink_cmd_velocity_message.id, MAVLink_cmd_velocity_message.name)
                self._fieldnames = MAVLink_cmd_velocity_message.fieldnames
                self._instance_field = MAVLink_cmd_velocity_message.instance_field
                self._instance_offset = MAVLink_cmd_velocity_message.instance_offset
                self.v = v
                self.omega = omega

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 202, struct.pack('<ff', self.v, self.omega), force_mavlink1=force_mavlink1)

class MAVLink_evt_tilt_message(MAVLink_message):
        '''
        Tilt angle of robot in the calibrated vertical axis. No need a
        respond message for confimation
        '''
        id = MAVLINK_MSG_ID_EVT_TILT
        name = 'EVT_TILT'
        fieldnames = ['tilt']
        ordered_fieldnames = ['tilt']
        fieldtypes = ['float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<f'
        native_format = bytearray('<f', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 83
        unpacker = struct.Struct('<f')
        instance_field = None
        instance_offset = -1

        def __init__(self, tilt):
                MAVLink_message.__init__(self, MAVLink_evt_tilt_message.id, MAVLink_evt_tilt_message.name)
                self._fieldnames = MAVLink_evt_tilt_message.fieldnames
                self._instance_field = MAVLink_evt_tilt_message.instance_field
                self._instance_offset = MAVLink_evt_tilt_message.instance_offset
                self.tilt = tilt

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 83, struct.pack('<f', self.tilt), force_mavlink1=force_mavlink1)

class MAVLink_evt_rpy_message(MAVLink_message):
        '''
        Roll pitch and yaw angle of robot in the earth frame. No need
        a respond message for confimation
        '''
        id = MAVLINK_MSG_ID_EVT_RPY
        name = 'EVT_RPY'
        fieldnames = ['roll', 'pitch', 'yaw']
        ordered_fieldnames = ['roll', 'pitch', 'yaw']
        fieldtypes = ['float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<fff'
        native_format = bytearray('<fff', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 93
        unpacker = struct.Struct('<fff')
        instance_field = None
        instance_offset = -1

        def __init__(self, roll, pitch, yaw):
                MAVLink_message.__init__(self, MAVLink_evt_rpy_message.id, MAVLink_evt_rpy_message.name)
                self._fieldnames = MAVLink_evt_rpy_message.fieldnames
                self._instance_field = MAVLink_evt_rpy_message.instance_field
                self._instance_offset = MAVLink_evt_rpy_message.instance_offset
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 93, struct.pack('<fff', self.roll, self.pitch, self.yaw), force_mavlink1=force_mavlink1)

class MAVLink_evt_sensor_message(MAVLink_message):
        '''
        Report sensor status. No need a respond message for
        confimation
        '''
        id = MAVLINK_MSG_ID_EVT_SENSOR
        name = 'EVT_SENSOR'
        fieldnames = ['imu_status']
        ordered_fieldnames = ['imu_status']
        fieldtypes = ['int8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"imu_status": "sensor_t"}
        fieldunits_by_name = {}
        format = '<b'
        native_format = bytearray('<b', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 54
        unpacker = struct.Struct('<b')
        instance_field = None
        instance_offset = -1

        def __init__(self, imu_status):
                MAVLink_message.__init__(self, MAVLink_evt_sensor_message.id, MAVLink_evt_sensor_message.name)
                self._fieldnames = MAVLink_evt_sensor_message.fieldnames
                self._instance_field = MAVLink_evt_sensor_message.instance_field
                self._instance_offset = MAVLink_evt_sensor_message.instance_offset
                self.imu_status = imu_status

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 54, struct.pack('<b', self.imu_status), force_mavlink1=force_mavlink1)

class MAVLink_motor_speed_message(MAVLink_message):
        '''
        Set or info speed for motors. To test the hardware and motor
        rotaion direction. No need a respond message for confimation
        '''
        id = MAVLINK_MSG_ID_MOTOR_SPEED
        name = 'MOTOR_SPEED'
        fieldnames = ['motor_speed_0', 'motor_speed_1']
        ordered_fieldnames = ['motor_speed_0', 'motor_speed_1']
        fieldtypes = ['int16_t', 'int16_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<hh'
        native_format = bytearray('<hh', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 183
        unpacker = struct.Struct('<hh')
        instance_field = None
        instance_offset = -1

        def __init__(self, motor_speed_0, motor_speed_1):
                MAVLink_message.__init__(self, MAVLink_motor_speed_message.id, MAVLink_motor_speed_message.name)
                self._fieldnames = MAVLink_motor_speed_message.fieldnames
                self._instance_field = MAVLink_motor_speed_message.instance_field
                self._instance_offset = MAVLink_motor_speed_message.instance_offset
                self.motor_speed_0 = motor_speed_0
                self.motor_speed_1 = motor_speed_1

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 183, struct.pack('<hh', self.motor_speed_0, self.motor_speed_1), force_mavlink1=force_mavlink1)

class MAVLink_hw_params_message(MAVLink_message):
        '''
        Switch to invert motor rotation direction. Need a respond
        message for confimation
        '''
        id = MAVLINK_MSG_ID_HW_PARAMS
        name = 'HW_PARAMS'
        fieldnames = ['motor0_invert', 'motor1_invert', 'encoder0_invert', 'encoder1_invert', 'encoder_exchange', 'motor0_pos_deadband', 'motor0_neg_deadband', 'motor1_pos_deadband', 'motor1_neg_deadband']
        ordered_fieldnames = ['motor0_pos_deadband', 'motor0_neg_deadband', 'motor1_pos_deadband', 'motor1_neg_deadband', 'motor0_invert', 'motor1_invert', 'encoder0_invert', 'encoder1_invert', 'encoder_exchange']
        fieldtypes = ['int8_t', 'int8_t', 'int8_t', 'int8_t', 'int8_t', 'int16_t', 'int16_t', 'int16_t', 'int16_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"motor0_invert": "bool_t", "motor1_invert": "bool_t", "encoder0_invert": "bool_t", "encoder1_invert": "bool_t", "encoder_exchange": "bool_t"}
        fieldunits_by_name = {}
        format = '<hhhhbbbbb'
        native_format = bytearray('<hhhhbbbbb', 'ascii')
        orders = [4, 5, 6, 7, 8, 0, 1, 2, 3]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 55
        unpacker = struct.Struct('<hhhhbbbbb')
        instance_field = None
        instance_offset = -1

        def __init__(self, motor0_invert, motor1_invert, encoder0_invert, encoder1_invert, encoder_exchange, motor0_pos_deadband, motor0_neg_deadband, motor1_pos_deadband, motor1_neg_deadband):
                MAVLink_message.__init__(self, MAVLink_hw_params_message.id, MAVLink_hw_params_message.name)
                self._fieldnames = MAVLink_hw_params_message.fieldnames
                self._instance_field = MAVLink_hw_params_message.instance_field
                self._instance_offset = MAVLink_hw_params_message.instance_offset
                self.motor0_invert = motor0_invert
                self.motor1_invert = motor1_invert
                self.encoder0_invert = encoder0_invert
                self.encoder1_invert = encoder1_invert
                self.encoder_exchange = encoder_exchange
                self.motor0_pos_deadband = motor0_pos_deadband
                self.motor0_neg_deadband = motor0_neg_deadband
                self.motor1_pos_deadband = motor1_pos_deadband
                self.motor1_neg_deadband = motor1_neg_deadband

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 55, struct.pack('<hhhhbbbbb', self.motor0_pos_deadband, self.motor0_neg_deadband, self.motor1_pos_deadband, self.motor1_neg_deadband, self.motor0_invert, self.motor1_invert, self.encoder0_invert, self.encoder1_invert, self.encoder_exchange), force_mavlink1=force_mavlink1)

class MAVLink_gyro_params_message(MAVLink_message):
        '''
        Gyro calibration parameters. No need a respond message for
        confimation
        '''
        id = MAVLINK_MSG_ID_GYRO_PARAMS
        name = 'GYRO_PARAMS'
        fieldnames = ['gyro_offset_x', 'gyro_offset_y', 'gyro_offset_z']
        ordered_fieldnames = ['gyro_offset_x', 'gyro_offset_y', 'gyro_offset_z']
        fieldtypes = ['float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<fff'
        native_format = bytearray('<fff', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 249
        unpacker = struct.Struct('<fff')
        instance_field = None
        instance_offset = -1

        def __init__(self, gyro_offset_x, gyro_offset_y, gyro_offset_z):
                MAVLink_message.__init__(self, MAVLink_gyro_params_message.id, MAVLink_gyro_params_message.name)
                self._fieldnames = MAVLink_gyro_params_message.fieldnames
                self._instance_field = MAVLink_gyro_params_message.instance_field
                self._instance_offset = MAVLink_gyro_params_message.instance_offset
                self.gyro_offset_x = gyro_offset_x
                self.gyro_offset_y = gyro_offset_y
                self.gyro_offset_z = gyro_offset_z

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 249, struct.pack('<fff', self.gyro_offset_x, self.gyro_offset_y, self.gyro_offset_z), force_mavlink1=force_mavlink1)

class MAVLink_comp_filter_params_message(MAVLink_message):
        '''
        Complimentary filter parameters. No need a respond message for
        confimation
        '''
        id = MAVLINK_MSG_ID_COMP_FILTER_PARAMS
        name = 'COMP_FILTER_PARAMS'
        fieldnames = ['tilt_type', 'tilt_offset', 'g_believe']
        ordered_fieldnames = ['tilt_offset', 'g_believe', 'tilt_type']
        fieldtypes = ['uint8_t', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"tilt_type": "tilt_type_t"}
        fieldunits_by_name = {}
        format = '<ffB'
        native_format = bytearray('<ffB', 'ascii')
        orders = [2, 0, 1]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 157
        unpacker = struct.Struct('<ffB')
        instance_field = None
        instance_offset = -1

        def __init__(self, tilt_type, tilt_offset, g_believe):
                MAVLink_message.__init__(self, MAVLink_comp_filter_params_message.id, MAVLink_comp_filter_params_message.name)
                self._fieldnames = MAVLink_comp_filter_params_message.fieldnames
                self._instance_field = MAVLink_comp_filter_params_message.instance_field
                self._instance_offset = MAVLink_comp_filter_params_message.instance_offset
                self.tilt_type = tilt_type
                self.tilt_offset = tilt_offset
                self.g_believe = g_believe

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 157, struct.pack('<ffB', self.tilt_offset, self.g_believe, self.tilt_type), force_mavlink1=force_mavlink1)

class MAVLink_evt_accel_raw_message(MAVLink_message):
        '''
        IMU raw value. No need a respond message for confimation
        '''
        id = MAVLINK_MSG_ID_EVT_ACCEL_RAW
        name = 'EVT_ACCEL_RAW'
        fieldnames = ['acc_x', 'acc_y', 'acc_z']
        ordered_fieldnames = ['acc_x', 'acc_y', 'acc_z']
        fieldtypes = ['float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<fff'
        native_format = bytearray('<fff', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 117
        unpacker = struct.Struct('<fff')
        instance_field = None
        instance_offset = -1

        def __init__(self, acc_x, acc_y, acc_z):
                MAVLink_message.__init__(self, MAVLink_evt_accel_raw_message.id, MAVLink_evt_accel_raw_message.name)
                self._fieldnames = MAVLink_evt_accel_raw_message.fieldnames
                self._instance_field = MAVLink_evt_accel_raw_message.instance_field
                self._instance_offset = MAVLink_evt_accel_raw_message.instance_offset
                self.acc_x = acc_x
                self.acc_y = acc_y
                self.acc_z = acc_z

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 117, struct.pack('<fff', self.acc_x, self.acc_y, self.acc_z), force_mavlink1=force_mavlink1)

class MAVLink_evt_gyro_raw_message(MAVLink_message):
        '''
        IMU raw value. No need a respond message for confimation
        '''
        id = MAVLINK_MSG_ID_EVT_GYRO_RAW
        name = 'EVT_GYRO_RAW'
        fieldnames = ['gyro_x', 'gyro_y', 'gyro_z']
        ordered_fieldnames = ['gyro_x', 'gyro_y', 'gyro_z']
        fieldtypes = ['float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<fff'
        native_format = bytearray('<fff', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 142
        unpacker = struct.Struct('<fff')
        instance_field = None
        instance_offset = -1

        def __init__(self, gyro_x, gyro_y, gyro_z):
                MAVLink_message.__init__(self, MAVLink_evt_gyro_raw_message.id, MAVLink_evt_gyro_raw_message.name)
                self._fieldnames = MAVLink_evt_gyro_raw_message.fieldnames
                self._instance_field = MAVLink_evt_gyro_raw_message.instance_field
                self._instance_offset = MAVLink_evt_gyro_raw_message.instance_offset
                self.gyro_x = gyro_x
                self.gyro_y = gyro_y
                self.gyro_z = gyro_z

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 142, struct.pack('<fff', self.gyro_x, self.gyro_y, self.gyro_z), force_mavlink1=force_mavlink1)

class MAVLink_evt_calibrated_gyro_raw_message(MAVLink_message):
        '''
        IMU raw value. No need a respond message for confimation
        '''
        id = MAVLINK_MSG_ID_EVT_CALIBRATED_GYRO_RAW
        name = 'EVT_CALIBRATED_GYRO_RAW'
        fieldnames = ['gyro_x', 'gyro_y', 'gyro_z']
        ordered_fieldnames = ['gyro_x', 'gyro_y', 'gyro_z']
        fieldtypes = ['float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<fff'
        native_format = bytearray('<fff', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 57
        unpacker = struct.Struct('<fff')
        instance_field = None
        instance_offset = -1

        def __init__(self, gyro_x, gyro_y, gyro_z):
                MAVLink_message.__init__(self, MAVLink_evt_calibrated_gyro_raw_message.id, MAVLink_evt_calibrated_gyro_raw_message.name)
                self._fieldnames = MAVLink_evt_calibrated_gyro_raw_message.fieldnames
                self._instance_field = MAVLink_evt_calibrated_gyro_raw_message.instance_field
                self._instance_offset = MAVLink_evt_calibrated_gyro_raw_message.instance_offset
                self.gyro_x = gyro_x
                self.gyro_y = gyro_y
                self.gyro_z = gyro_z

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 57, struct.pack('<fff', self.gyro_x, self.gyro_y, self.gyro_z), force_mavlink1=force_mavlink1)

class MAVLink_evt_mag_raw_message(MAVLink_message):
        '''
        IMU raw value. No need a respond message for confimation
        '''
        id = MAVLINK_MSG_ID_EVT_MAG_RAW
        name = 'EVT_MAG_RAW'
        fieldnames = ['mag_x', 'mag_y', 'mag_z']
        ordered_fieldnames = ['mag_x', 'mag_y', 'mag_z']
        fieldtypes = ['float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<fff'
        native_format = bytearray('<fff', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 76
        unpacker = struct.Struct('<fff')
        instance_field = None
        instance_offset = -1

        def __init__(self, mag_x, mag_y, mag_z):
                MAVLink_message.__init__(self, MAVLink_evt_mag_raw_message.id, MAVLink_evt_mag_raw_message.name)
                self._fieldnames = MAVLink_evt_mag_raw_message.fieldnames
                self._instance_field = MAVLink_evt_mag_raw_message.instance_field
                self._instance_offset = MAVLink_evt_mag_raw_message.instance_offset
                self.mag_x = mag_x
                self.mag_y = mag_y
                self.mag_z = mag_z

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 76, struct.pack('<fff', self.mag_x, self.mag_y, self.mag_z), force_mavlink1=force_mavlink1)

class MAVLink_pid_params_message(MAVLink_message):
        '''
        PID Coefficent. No need a respond message for confimation
        '''
        id = MAVLINK_MSG_ID_PID_PARAMS
        name = 'PID_PARAMS'
        fieldnames = ['pid_control', 'KP', 'KI', 'KD']
        ordered_fieldnames = ['KP', 'KI', 'KD', 'pid_control']
        fieldtypes = ['uint8_t', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"pid_control": "pidc_t"}
        fieldunits_by_name = {}
        format = '<fffB'
        native_format = bytearray('<fffB', 'ascii')
        orders = [3, 0, 1, 2]
        lengths = [1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0]
        crc_extra = 2
        unpacker = struct.Struct('<fffB')
        instance_field = None
        instance_offset = -1

        def __init__(self, pid_control, KP, KI, KD):
                MAVLink_message.__init__(self, MAVLink_pid_params_message.id, MAVLink_pid_params_message.name)
                self._fieldnames = MAVLink_pid_params_message.fieldnames
                self._instance_field = MAVLink_pid_params_message.instance_field
                self._instance_offset = MAVLink_pid_params_message.instance_offset
                self.pid_control = pid_control
                self.KP = KP
                self.KI = KI
                self.KD = KD

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 2, struct.pack('<fffB', self.KP, self.KI, self.KD, self.pid_control), force_mavlink1=force_mavlink1)

class MAVLink_pid_report_message(MAVLink_message):
        '''
        Report pid internal parameter
        '''
        id = MAVLINK_MSG_ID_PID_REPORT
        name = 'PID_REPORT'
        fieldnames = ['pid_control', 'sp', 'fb', 'P_Part', 'I_Part', 'D_Part', 'U']
        ordered_fieldnames = ['sp', 'fb', 'P_Part', 'I_Part', 'D_Part', 'U', 'pid_control']
        fieldtypes = ['uint8_t', 'float', 'float', 'float', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"pid_control": "pidc_t"}
        fieldunits_by_name = {}
        format = '<ffffffB'
        native_format = bytearray('<ffffffB', 'ascii')
        orders = [6, 0, 1, 2, 3, 4, 5]
        lengths = [1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0]
        crc_extra = 198
        unpacker = struct.Struct('<ffffffB')
        instance_field = None
        instance_offset = -1

        def __init__(self, pid_control, sp, fb, P_Part, I_Part, D_Part, U):
                MAVLink_message.__init__(self, MAVLink_pid_report_message.id, MAVLink_pid_report_message.name)
                self._fieldnames = MAVLink_pid_report_message.fieldnames
                self._instance_field = MAVLink_pid_report_message.instance_field
                self._instance_offset = MAVLink_pid_report_message.instance_offset
                self.pid_control = pid_control
                self.sp = sp
                self.fb = fb
                self.P_Part = P_Part
                self.I_Part = I_Part
                self.D_Part = D_Part
                self.U = U

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 198, struct.pack('<ffffffB', self.sp, self.fb, self.P_Part, self.I_Part, self.D_Part, self.U, self.pid_control), force_mavlink1=force_mavlink1)

class MAVLink_blink_message(MAVLink_message):
        '''
        Location message
        '''
        id = MAVLINK_MSG_ID_BLINK
        name = 'BLINK'
        fieldnames = ['uwb_address', 'role']
        ordered_fieldnames = ['uwb_address', 'role']
        fieldtypes = ['uint16_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"role": "role_t"}
        fieldunits_by_name = {}
        format = '<HB'
        native_format = bytearray('<HB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 92
        unpacker = struct.Struct('<HB')
        instance_field = None
        instance_offset = -1

        def __init__(self, uwb_address, role):
                MAVLink_message.__init__(self, MAVLink_blink_message.id, MAVLink_blink_message.name)
                self._fieldnames = MAVLink_blink_message.fieldnames
                self._instance_field = MAVLink_blink_message.instance_field
                self._instance_offset = MAVLink_blink_message.instance_offset
                self.uwb_address = uwb_address
                self.role = role

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 92, struct.pack('<HB', self.uwb_address, self.role), force_mavlink1=force_mavlink1)

class MAVLink_ble_mesh_message(MAVLink_message):
        '''
        BLE mesh message
        '''
        id = MAVLINK_MSG_ID_BLE_MESH
        name = 'BLE_MESH'
        fieldnames = ['uwb_address', 'mesh_address']
        ordered_fieldnames = ['uwb_address', 'mesh_address']
        fieldtypes = ['uint16_t', 'uint16_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<HH'
        native_format = bytearray('<HH', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 91
        unpacker = struct.Struct('<HH')
        instance_field = None
        instance_offset = -1

        def __init__(self, uwb_address, mesh_address):
                MAVLink_message.__init__(self, MAVLink_ble_mesh_message.id, MAVLink_ble_mesh_message.name)
                self._fieldnames = MAVLink_ble_mesh_message.fieldnames
                self._instance_field = MAVLink_ble_mesh_message.instance_field
                self._instance_offset = MAVLink_ble_mesh_message.instance_offset
                self.uwb_address = uwb_address
                self.mesh_address = mesh_address

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 91, struct.pack('<HH', self.uwb_address, self.mesh_address), force_mavlink1=force_mavlink1)

class MAVLink_onoff_message(MAVLink_message):
        '''
        On off message
        '''
        id = MAVLINK_MSG_ID_ONOFF
        name = 'ONOFF'
        fieldnames = ['uwb_address', 'value']
        ordered_fieldnames = ['uwb_address', 'value']
        fieldtypes = ['uint16_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<HB'
        native_format = bytearray('<HB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 35
        unpacker = struct.Struct('<HB')
        instance_field = None
        instance_offset = -1

        def __init__(self, uwb_address, value):
                MAVLink_message.__init__(self, MAVLink_onoff_message.id, MAVLink_onoff_message.name)
                self._fieldnames = MAVLink_onoff_message.fieldnames
                self._instance_field = MAVLink_onoff_message.instance_field
                self._instance_offset = MAVLink_onoff_message.instance_offset
                self.uwb_address = uwb_address
                self.value = value

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 35, struct.pack('<HB', self.uwb_address, self.value), force_mavlink1=force_mavlink1)

class MAVLink_location_message(MAVLink_message):
        '''
        Location message
        '''
        id = MAVLINK_MSG_ID_LOCATION
        name = 'LOCATION'
        fieldnames = ['uwb_address', 'location_x', 'location_y', 'location_z']
        ordered_fieldnames = ['location_x', 'location_y', 'location_z', 'uwb_address']
        fieldtypes = ['uint16_t', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<fffH'
        native_format = bytearray('<fffH', 'ascii')
        orders = [3, 0, 1, 2]
        lengths = [1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0]
        crc_extra = 170
        unpacker = struct.Struct('<fffH')
        instance_field = None
        instance_offset = -1

        def __init__(self, uwb_address, location_x, location_y, location_z):
                MAVLink_message.__init__(self, MAVLink_location_message.id, MAVLink_location_message.name)
                self._fieldnames = MAVLink_location_message.fieldnames
                self._instance_field = MAVLink_location_message.instance_field
                self._instance_offset = MAVLink_location_message.instance_offset
                self.uwb_address = uwb_address
                self.location_x = location_x
                self.location_y = location_y
                self.location_z = location_z

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 170, struct.pack('<fffH', self.location_x, self.location_y, self.location_z, self.uwb_address), force_mavlink1=force_mavlink1)

class MAVLink_location_reduced_message(MAVLink_message):
        '''
        Location message
        '''
        id = MAVLINK_MSG_ID_LOCATION_REDUCED
        name = 'LOCATION_REDUCED'
        fieldnames = ['mesh_address', 'location_x', 'location_y']
        ordered_fieldnames = ['location_x', 'location_y', 'mesh_address']
        fieldtypes = ['uint16_t', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<ffH'
        native_format = bytearray('<ffH', 'ascii')
        orders = [2, 0, 1]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 244
        unpacker = struct.Struct('<ffH')
        instance_field = None
        instance_offset = -1

        def __init__(self, mesh_address, location_x, location_y):
                MAVLink_message.__init__(self, MAVLink_location_reduced_message.id, MAVLink_location_reduced_message.name)
                self._fieldnames = MAVLink_location_reduced_message.fieldnames
                self._instance_field = MAVLink_location_reduced_message.instance_field
                self._instance_offset = MAVLink_location_reduced_message.instance_offset
                self.mesh_address = mesh_address
                self.location_x = location_x
                self.location_y = location_y

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 244, struct.pack('<ffH', self.location_x, self.location_y, self.mesh_address), force_mavlink1=force_mavlink1)

class MAVLink_distance_message(MAVLink_message):
        '''
        Distance message
        '''
        id = MAVLINK_MSG_ID_DISTANCE
        name = 'DISTANCE'
        fieldnames = ['uwb_address', 'anchor', 'distance']
        ordered_fieldnames = ['distance', 'uwb_address', 'anchor']
        fieldtypes = ['uint16_t', 'uint16_t', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<fHH'
        native_format = bytearray('<fHH', 'ascii')
        orders = [1, 2, 0]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 33
        unpacker = struct.Struct('<fHH')
        instance_field = None
        instance_offset = -1

        def __init__(self, uwb_address, anchor, distance):
                MAVLink_message.__init__(self, MAVLink_distance_message.id, MAVLink_distance_message.name)
                self._fieldnames = MAVLink_distance_message.fieldnames
                self._instance_field = MAVLink_distance_message.instance_field
                self._instance_offset = MAVLink_distance_message.instance_offset
                self.uwb_address = uwb_address
                self.anchor = anchor
                self.distance = distance

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 33, struct.pack('<fHH', self.distance, self.uwb_address, self.anchor), force_mavlink1=force_mavlink1)

class MAVLink_tof_message(MAVLink_message):
        '''
        TOF message
        '''
        id = MAVLINK_MSG_ID_TOF
        name = 'TOF'
        fieldnames = ['uwb_address', 'anchor', 'tof']
        ordered_fieldnames = ['tof', 'uwb_address', 'anchor']
        fieldtypes = ['uint16_t', 'uint16_t', 'uint32_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<IHH'
        native_format = bytearray('<IHH', 'ascii')
        orders = [1, 2, 0]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 4
        unpacker = struct.Struct('<IHH')
        instance_field = None
        instance_offset = -1

        def __init__(self, uwb_address, anchor, tof):
                MAVLink_message.__init__(self, MAVLink_tof_message.id, MAVLink_tof_message.name)
                self._fieldnames = MAVLink_tof_message.fieldnames
                self._instance_field = MAVLink_tof_message.instance_field
                self._instance_offset = MAVLink_tof_message.instance_offset
                self.uwb_address = uwb_address
                self.anchor = anchor
                self.tof = tof

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 4, struct.pack('<IHH', self.tof, self.uwb_address, self.anchor), force_mavlink1=force_mavlink1)

class MAVLink_slot_message(MAVLink_message):
        '''
        Slot message
        '''
        id = MAVLINK_MSG_ID_SLOT
        name = 'SLOT'
        fieldnames = ['uwb_address', 'slot']
        ordered_fieldnames = ['uwb_address', 'slot']
        fieldtypes = ['uint16_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<HB'
        native_format = bytearray('<HB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 177
        unpacker = struct.Struct('<HB')
        instance_field = None
        instance_offset = -1

        def __init__(self, uwb_address, slot):
                MAVLink_message.__init__(self, MAVLink_slot_message.id, MAVLink_slot_message.name)
                self._fieldnames = MAVLink_slot_message.fieldnames
                self._instance_field = MAVLink_slot_message.instance_field
                self._instance_offset = MAVLink_slot_message.instance_offset
                self.uwb_address = uwb_address
                self.slot = slot

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 177, struct.pack('<HB', self.uwb_address, self.slot), force_mavlink1=force_mavlink1)

class MAVLink_tag_message(MAVLink_message):
        '''
        Tag message
        '''
        id = MAVLINK_MSG_ID_TAG
        name = 'TAG'
        fieldnames = ['a0', 'a0x', 'a0y', 'a0z', 'a0r', 'a1', 'a1x', 'a1y', 'a1z', 'a1r', 'a2', 'a2x', 'a2y', 'a2z', 'a2r', 'a3', 'a3x', 'a3y', 'a3z', 'a3r', 't0', 't0x', 't0y', 't0z']
        ordered_fieldnames = ['a0x', 'a0y', 'a0z', 'a0r', 'a1x', 'a1y', 'a1z', 'a1r', 'a2x', 'a2y', 'a2z', 'a2r', 'a3x', 'a3y', 'a3z', 'a3r', 't0x', 't0y', 't0z', 'a0', 'a1', 'a2', 'a3', 't0']
        fieldtypes = ['uint16_t', 'float', 'float', 'float', 'float', 'uint16_t', 'float', 'float', 'float', 'float', 'uint16_t', 'float', 'float', 'float', 'float', 'uint16_t', 'float', 'float', 'float', 'float', 'uint16_t', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<fffffffffffffffffffHHHHH'
        native_format = bytearray('<fffffffffffffffffffHHHHH', 'ascii')
        orders = [19, 0, 1, 2, 3, 20, 4, 5, 6, 7, 21, 8, 9, 10, 11, 22, 12, 13, 14, 15, 23, 16, 17, 18]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 71
        unpacker = struct.Struct('<fffffffffffffffffffHHHHH')
        instance_field = None
        instance_offset = -1

        def __init__(self, a0, a0x, a0y, a0z, a0r, a1, a1x, a1y, a1z, a1r, a2, a2x, a2y, a2z, a2r, a3, a3x, a3y, a3z, a3r, t0, t0x, t0y, t0z):
                MAVLink_message.__init__(self, MAVLink_tag_message.id, MAVLink_tag_message.name)
                self._fieldnames = MAVLink_tag_message.fieldnames
                self._instance_field = MAVLink_tag_message.instance_field
                self._instance_offset = MAVLink_tag_message.instance_offset
                self.a0 = a0
                self.a0x = a0x
                self.a0y = a0y
                self.a0z = a0z
                self.a0r = a0r
                self.a1 = a1
                self.a1x = a1x
                self.a1y = a1y
                self.a1z = a1z
                self.a1r = a1r
                self.a2 = a2
                self.a2x = a2x
                self.a2y = a2y
                self.a2z = a2z
                self.a2r = a2r
                self.a3 = a3
                self.a3x = a3x
                self.a3y = a3y
                self.a3z = a3z
                self.a3r = a3r
                self.t0 = t0
                self.t0x = t0x
                self.t0y = t0y
                self.t0z = t0z

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 71, struct.pack('<fffffffffffffffffffHHHHH', self.a0x, self.a0y, self.a0z, self.a0r, self.a1x, self.a1y, self.a1z, self.a1r, self.a2x, self.a2y, self.a2z, self.a2r, self.a3x, self.a3y, self.a3z, self.a3r, self.t0x, self.t0y, self.t0z, self.a0, self.a1, self.a2, self.a3, self.t0), force_mavlink1=force_mavlink1)


mavlink_map = {
        MAVLINK_MSG_ID_RESPOND : MAVLink_respond_message,
        MAVLINK_MSG_ID_CMD_CHANGE_MODE : MAVLink_cmd_change_mode_message,
        MAVLINK_MSG_ID_CMD_PARAMS : MAVLink_cmd_params_message,
        MAVLINK_MSG_ID_CMD_VELOCITY : MAVLink_cmd_velocity_message,
        MAVLINK_MSG_ID_EVT_TILT : MAVLink_evt_tilt_message,
        MAVLINK_MSG_ID_EVT_RPY : MAVLink_evt_rpy_message,
        MAVLINK_MSG_ID_EVT_SENSOR : MAVLink_evt_sensor_message,
        MAVLINK_MSG_ID_MOTOR_SPEED : MAVLink_motor_speed_message,
        MAVLINK_MSG_ID_HW_PARAMS : MAVLink_hw_params_message,
        MAVLINK_MSG_ID_GYRO_PARAMS : MAVLink_gyro_params_message,
        MAVLINK_MSG_ID_COMP_FILTER_PARAMS : MAVLink_comp_filter_params_message,
        MAVLINK_MSG_ID_EVT_ACCEL_RAW : MAVLink_evt_accel_raw_message,
        MAVLINK_MSG_ID_EVT_GYRO_RAW : MAVLink_evt_gyro_raw_message,
        MAVLINK_MSG_ID_EVT_CALIBRATED_GYRO_RAW : MAVLink_evt_calibrated_gyro_raw_message,
        MAVLINK_MSG_ID_EVT_MAG_RAW : MAVLink_evt_mag_raw_message,
        MAVLINK_MSG_ID_PID_PARAMS : MAVLink_pid_params_message,
        MAVLINK_MSG_ID_PID_REPORT : MAVLink_pid_report_message,
        MAVLINK_MSG_ID_BLINK : MAVLink_blink_message,
        MAVLINK_MSG_ID_BLE_MESH : MAVLink_ble_mesh_message,
        MAVLINK_MSG_ID_ONOFF : MAVLink_onoff_message,
        MAVLINK_MSG_ID_LOCATION : MAVLink_location_message,
        MAVLINK_MSG_ID_LOCATION_REDUCED : MAVLink_location_reduced_message,
        MAVLINK_MSG_ID_DISTANCE : MAVLink_distance_message,
        MAVLINK_MSG_ID_TOF : MAVLink_tof_message,
        MAVLINK_MSG_ID_SLOT : MAVLink_slot_message,
        MAVLINK_MSG_ID_TAG : MAVLink_tag_message,
}

class MAVError(Exception):
        '''MAVLink error class'''
        def __init__(self, msg):
            Exception.__init__(self, msg)
            self.message = msg

class MAVString(str):
        '''NUL terminated string'''
        def __init__(self, s):
                str.__init__(self)
        def __str__(self):
            i = self.find(chr(0))
            if i == -1:
                return self[:]
            return self[0:i]

class MAVLink_bad_data(MAVLink_message):
        '''
        a piece of bad data in a mavlink stream
        '''
        def __init__(self, data, reason):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_BAD_DATA, 'BAD_DATA')
                self._fieldnames = ['data', 'reason']
                self.data = data
                self.reason = reason
                self._msgbuf = data
                self._instance_field = None

        def __str__(self):
            '''Override the __str__ function from MAVLink_messages because non-printable characters are common in to be the reason for this message to exist.'''
            return '%s {%s, data:%s}' % (self._type, self.reason, [('%x' % ord(i) if isinstance(i, str) else '%x' % i) for i in self.data])

class MAVLinkSigning(object):
    '''MAVLink signing state class'''
    def __init__(self):
        self.secret_key = None
        self.timestamp = 0
        self.link_id = 0
        self.sign_outgoing = False
        self.allow_unsigned_callback = None
        self.stream_timestamps = {}
        self.sig_count = 0
        self.badsig_count = 0
        self.goodsig_count = 0
        self.unsigned_count = 0
        self.reject_count = 0

class MAVLink(object):
        '''MAVLink protocol handling class'''
        def __init__(self, file, srcSystem=0, srcComponent=0, use_native=False):
                self.seq = 0
                self.file = file
                self.srcSystem = srcSystem
                self.srcComponent = srcComponent
                self.callback = None
                self.callback_args = None
                self.callback_kwargs = None
                self.send_callback = None
                self.send_callback_args = None
                self.send_callback_kwargs = None
                self.buf = bytearray()
                self.buf_index = 0
                self.expected_length = HEADER_LEN_V1+2
                self.have_prefix_error = False
                self.robust_parsing = False
                self.protocol_marker = 254
                self.little_endian = True
                self.crc_extra = True
                self.sort_fields = True
                self.total_packets_sent = 0
                self.total_bytes_sent = 0
                self.total_packets_received = 0
                self.total_bytes_received = 0
                self.total_receive_errors = 0
                self.startup_time = time.time()
                self.signing = MAVLinkSigning()
                if native_supported and (use_native or native_testing or native_force):
                    print("NOTE: mavnative is currently beta-test code")
                    self.native = mavnative.NativeConnection(MAVLink_message, mavlink_map)
                else:
                    self.native = None
                if native_testing:
                    self.test_buf = bytearray()
                self.mav20_unpacker = struct.Struct('<cBBBBBBHB')
                self.mav10_unpacker = struct.Struct('<cBBBBB')
                self.mav20_h3_unpacker = struct.Struct('BBB')
                self.mav_csum_unpacker = struct.Struct('<H')
                self.mav_sign_unpacker = struct.Struct('<IH')

        def set_callback(self, callback, *args, **kwargs):
            self.callback = callback
            self.callback_args = args
            self.callback_kwargs = kwargs

        def set_send_callback(self, callback, *args, **kwargs):
            self.send_callback = callback
            self.send_callback_args = args
            self.send_callback_kwargs = kwargs

        def send(self, mavmsg, force_mavlink1=False):
                '''send a MAVLink message'''
                buf = mavmsg.pack(self, force_mavlink1=force_mavlink1)
                self.file.write(buf)
                self.seq = (self.seq + 1) % 256
                self.total_packets_sent += 1
                self.total_bytes_sent += len(buf)
                if self.send_callback:
                    self.send_callback(mavmsg, *self.send_callback_args, **self.send_callback_kwargs)

        def buf_len(self):
            return len(self.buf) - self.buf_index

        def bytes_needed(self):
            '''return number of bytes needed for next parsing stage'''
            if self.native:
                ret = self.native.expected_length - self.buf_len()
            else:
                ret = self.expected_length - self.buf_len()

            if ret <= 0:
                return 1
            return ret

        def __parse_char_native(self, c):
            '''this method exists only to see in profiling results'''
            m = self.native.parse_chars(c)
            return m

        def __callbacks(self, msg):
            '''this method exists only to make profiling results easier to read'''
            if self.callback:
                self.callback(msg, *self.callback_args, **self.callback_kwargs)

        def parse_char(self, c):
            '''input some data bytes, possibly returning a new message'''
            self.buf.extend(c)

            self.total_bytes_received += len(c)

            if self.native:
                if native_testing:
                    self.test_buf.extend(c)
                    m = self.__parse_char_native(self.test_buf)
                    m2 = self.__parse_char_legacy()
                    if m2 != m:
                        print("Native: %s\nLegacy: %s\n" % (m, m2))
                        raise Exception('Native vs. Legacy mismatch')
                else:
                    m = self.__parse_char_native(self.buf)
            else:
                m = self.__parse_char_legacy()

            if m is not None:
                self.total_packets_received += 1
                self.__callbacks(m)
            else:
                # XXX The idea here is if we've read something and there's nothing left in
                # the buffer, reset it to 0 which frees the memory
                if self.buf_len() == 0 and self.buf_index != 0:
                    self.buf = bytearray()
                    self.buf_index = 0

            return m

        def __parse_char_legacy(self):
            '''input some data bytes, possibly returning a new message (uses no native code)'''
            header_len = HEADER_LEN_V1
            if self.buf_len() >= 1 and self.buf[self.buf_index] == PROTOCOL_MARKER_V2:
                header_len = HEADER_LEN_V2

            if self.buf_len() >= 1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V2:
                magic = self.buf[self.buf_index]
                self.buf_index += 1
                if self.robust_parsing:
                    m = MAVLink_bad_data(bytearray([magic]), 'Bad prefix')
                    self.expected_length = header_len+2
                    self.total_receive_errors += 1
                    return m
                if self.have_prefix_error:
                    return None
                self.have_prefix_error = True
                self.total_receive_errors += 1
                raise MAVError("invalid MAVLink prefix '%s'" % magic)
            self.have_prefix_error = False
            if self.buf_len() >= 3:
                sbuf = self.buf[self.buf_index:3+self.buf_index]
                if sys.version_info.major < 3:
                    sbuf = str(sbuf)
                (magic, self.expected_length, incompat_flags) = self.mav20_h3_unpacker.unpack(sbuf)
                if magic == PROTOCOL_MARKER_V2 and (incompat_flags & MAVLINK_IFLAG_SIGNED):
                        self.expected_length += MAVLINK_SIGNATURE_BLOCK_LEN
                self.expected_length += header_len + 2
            if self.expected_length >= (header_len+2) and self.buf_len() >= self.expected_length:
                mbuf = array.array('B', self.buf[self.buf_index:self.buf_index+self.expected_length])
                self.buf_index += self.expected_length
                self.expected_length = header_len+2
                if self.robust_parsing:
                    try:
                        if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                            raise MAVError('invalid incompat_flags 0x%x 0x%x %u' % (incompat_flags, magic, self.expected_length))
                        m = self.decode(mbuf)
                    except MAVError as reason:
                        m = MAVLink_bad_data(mbuf, reason.message)
                        self.total_receive_errors += 1
                else:
                    if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                        raise MAVError('invalid incompat_flags 0x%x 0x%x %u' % (incompat_flags, magic, self.expected_length))
                    m = self.decode(mbuf)
                return m
            return None

        def parse_buffer(self, s):
            '''input some data bytes, possibly returning a list of new messages'''
            m = self.parse_char(s)
            if m is None:
                return None
            ret = [m]
            while True:
                m = self.parse_char("")
                if m is None:
                    return ret
                ret.append(m)
            return ret

        def check_signature(self, msgbuf, srcSystem, srcComponent):
            '''check signature on incoming message'''
            if isinstance(msgbuf, array.array):
                msgbuf = msgbuf.tostring()
            timestamp_buf = msgbuf[-12:-6]
            link_id = msgbuf[-13]
            (tlow, thigh) = self.mav_sign_unpacker.unpack(timestamp_buf)
            timestamp = tlow + (thigh<<32)

            # see if the timestamp is acceptable
            stream_key = (link_id,srcSystem,srcComponent)
            if stream_key in self.signing.stream_timestamps:
                if timestamp <= self.signing.stream_timestamps[stream_key]:
                    # reject old timestamp
                    # print('old timestamp')
                    return False
            else:
                # a new stream has appeared. Accept the timestamp if it is at most
                # one minute behind our current timestamp
                if timestamp + 6000*1000 < self.signing.timestamp:
                    # print('bad new stream ', timestamp/(100.0*1000*60*60*24*365), self.signing.timestamp/(100.0*1000*60*60*24*365))
                    return False
                self.signing.stream_timestamps[stream_key] = timestamp
                # print('new stream')

            h = hashlib.new('sha256')
            h.update(self.signing.secret_key)
            h.update(msgbuf[:-6])
            if str(type(msgbuf)) == "<class 'bytes'>" or str(type(msgbuf)) == "<class 'bytearray'>":
                # Python 3
                sig1 = h.digest()[:6]
                sig2 = msgbuf[-6:]
            else:
                sig1 = str(h.digest())[:6]
                sig2 = str(msgbuf)[-6:]
            if sig1 != sig2:
                # print('sig mismatch')
                return False

            # the timestamp we next send with is the max of the received timestamp and
            # our current timestamp
            self.signing.timestamp = max(self.signing.timestamp, timestamp)
            return True

        # swiped from DFReader.py
        def to_string(self, s):
            '''desperate attempt to convert a string regardless of what garbage we get'''
            try:
                return s.decode("utf-8")
            except Exception as e:
                pass
            try:
                s2 = s.encode('utf-8', 'ignore')
                x = u"%s" % s2
                return s2
            except Exception:
                pass
            # so its a nasty one. Let's grab as many characters as we can
            r = ''
            while s != '':
                try:
                    r2 = r + s[0]
                    s = s[1:]
                    r2 = r2.encode('ascii', 'ignore')
                    x = u"%s" % r2
                    r = r2
                except Exception:
                    break
            return r + '_XXX'

        def decode(self, msgbuf):
                '''decode a buffer as a MAVLink message'''
                # decode the header
                if msgbuf[0] != PROTOCOL_MARKER_V1:
                    headerlen = 10
                    try:
                        magic, mlen, incompat_flags, compat_flags, seq, srcSystem, srcComponent, msgIdlow, msgIdhigh = self.mav20_unpacker.unpack(msgbuf[:headerlen])
                    except struct.error as emsg:
                        raise MAVError('Unable to unpack MAVLink header: %s' % emsg)
                    msgId = msgIdlow | (msgIdhigh<<16)
                    mapkey = msgId
                else:
                    headerlen = 6
                    try:
                        magic, mlen, seq, srcSystem, srcComponent, msgId = self.mav10_unpacker.unpack(msgbuf[:headerlen])
                        incompat_flags = 0
                        compat_flags = 0
                    except struct.error as emsg:
                        raise MAVError('Unable to unpack MAVLink header: %s' % emsg)
                    mapkey = msgId
                if (incompat_flags & MAVLINK_IFLAG_SIGNED) != 0:
                    signature_len = MAVLINK_SIGNATURE_BLOCK_LEN
                else:
                    signature_len = 0

                if ord(magic) != PROTOCOL_MARKER_V1 and ord(magic) != PROTOCOL_MARKER_V2:
                    raise MAVError("invalid MAVLink prefix '%s'" % magic)
                if mlen != len(msgbuf)-(headerlen+2+signature_len):
                    raise MAVError('invalid MAVLink message length. Got %u expected %u, msgId=%u headerlen=%u' % (len(msgbuf)-(headerlen+2+signature_len), mlen, msgId, headerlen))

                if not mapkey in mavlink_map:
                    raise MAVError('unknown MAVLink message ID %s' % str(mapkey))

                # decode the payload
                type = mavlink_map[mapkey]
                fmt = type.format
                order_map = type.orders
                len_map = type.lengths
                crc_extra = type.crc_extra

                # decode the checksum
                try:
                    crc, = self.mav_csum_unpacker.unpack(msgbuf[-(2+signature_len):][:2])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink CRC: %s' % emsg)
                crcbuf = msgbuf[1:-(2+signature_len)]
                if True: # using CRC extra
                    crcbuf.append(crc_extra)
                crc2 = x25crc(crcbuf)
                if crc != crc2.crc:
                    raise MAVError('invalid MAVLink CRC in msgID %u 0x%04x should be 0x%04x' % (msgId, crc, crc2.crc))

                sig_ok = False
                if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
                    self.signing.sig_count += 1
                if self.signing.secret_key is not None:
                    accept_signature = False
                    if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
                        sig_ok = self.check_signature(msgbuf, srcSystem, srcComponent)
                        accept_signature = sig_ok
                        if sig_ok:
                            self.signing.goodsig_count += 1
                        else:
                            self.signing.badsig_count += 1
                        if not accept_signature and self.signing.allow_unsigned_callback is not None:
                            accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                            if accept_signature:
                                self.signing.unsigned_count += 1
                            else:
                                self.signing.reject_count += 1
                    elif self.signing.allow_unsigned_callback is not None:
                        accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                        if accept_signature:
                            self.signing.unsigned_count += 1
                        else:
                            self.signing.reject_count += 1
                    if not accept_signature:
                        raise MAVError('Invalid signature')

                csize = type.unpacker.size
                mbuf = msgbuf[headerlen:-(2+signature_len)]
                if len(mbuf) < csize:
                    # zero pad to give right size
                    mbuf.extend([0]*(csize - len(mbuf)))
                if len(mbuf) < csize:
                    raise MAVError('Bad message of type %s length %u needs %s' % (
                        type, len(mbuf), csize))
                mbuf = mbuf[:csize]
                try:
                    t = type.unpacker.unpack(mbuf)
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink payload type=%s fmt=%s payloadLength=%u: %s' % (
                        type, fmt, len(mbuf), emsg))

                tlist = list(t)
                # handle sorted fields
                if True:
                    t = tlist[:]
                    if sum(len_map) == len(len_map):
                        # message has no arrays in it
                        for i in range(0, len(tlist)):
                            tlist[i] = t[order_map[i]]
                    else:
                        # message has some arrays
                        tlist = []
                        for i in range(0, len(order_map)):
                            order = order_map[i]
                            L = len_map[order]
                            tip = sum(len_map[:order])
                            field = t[tip]
                            if L == 1 or isinstance(field, str):
                                tlist.append(field)
                            else:
                                tlist.append(t[tip:(tip + L)])

                # terminate any strings
                for i in range(0, len(tlist)):
                    if type.fieldtypes[i] == 'char':
                        if sys.version_info.major >= 3:
                            tlist[i] = self.to_string(tlist[i])
                        tlist[i] = str(MAVString(tlist[i]))
                t = tuple(tlist)
                # construct the message object
                try:
                    m = type(*t)
                except Exception as emsg:
                    raise MAVError('Unable to instantiate MAVLink message of type %s : %s' % (type, emsg))
                m._signed = sig_ok
                if m._signed:
                    m._link_id = msgbuf[-13]
                m._msgbuf = msgbuf
                m._payload = msgbuf[6:-(2+signature_len)]
                m._crc = crc
                m._header = MAVLink_header(msgId, incompat_flags, compat_flags, mlen, seq, srcSystem, srcComponent)
                return m
        def respond_encode(self, respond):
                '''
                Respond for a reliable communication

                respond                   : Respond (type:uint8_t, values:resond_t)

                '''
                return MAVLink_respond_message(respond)

        def respond_send(self, respond, force_mavlink1=False):
                '''
                Respond for a reliable communication

                respond                   : Respond (type:uint8_t, values:resond_t)

                '''
                return self.send(self.respond_encode(respond), force_mavlink1=force_mavlink1)

        def cmd_change_mode_encode(self, cmd_change_mode):
                '''
                Command Change Mode. Need a respond message for confimation

                cmd_change_mode           : Mode (type:uint8_t, values:rmode_t)

                '''
                return MAVLink_cmd_change_mode_message(cmd_change_mode)

        def cmd_change_mode_send(self, cmd_change_mode, force_mavlink1=False):
                '''
                Command Change Mode. Need a respond message for confimation

                cmd_change_mode           : Mode (type:uint8_t, values:rmode_t)

                '''
                return self.send(self.cmd_change_mode_encode(cmd_change_mode), force_mavlink1=force_mavlink1)

        def cmd_params_encode(self, cmd_params):
                '''
                Save Or Load Params

                cmd_params                : save or load params (type:int8_t, values:cmd_params_t)

                '''
                return MAVLink_cmd_params_message(cmd_params)

        def cmd_params_send(self, cmd_params, force_mavlink1=False):
                '''
                Save Or Load Params

                cmd_params                : save or load params (type:int8_t, values:cmd_params_t)

                '''
                return self.send(self.cmd_params_encode(cmd_params), force_mavlink1=force_mavlink1)

        def cmd_velocity_encode(self, v, omega):
                '''
                Velocity command. No need a respond message for confimation

                v                         : Velocity (type:float)
                omega                     : Omega (type:float)

                '''
                return MAVLink_cmd_velocity_message(v, omega)

        def cmd_velocity_send(self, v, omega, force_mavlink1=False):
                '''
                Velocity command. No need a respond message for confimation

                v                         : Velocity (type:float)
                omega                     : Omega (type:float)

                '''
                return self.send(self.cmd_velocity_encode(v, omega), force_mavlink1=force_mavlink1)

        def evt_tilt_encode(self, tilt):
                '''
                Tilt angle of robot in the calibrated vertical axis. No need a respond
                message for confimation

                tilt                      : Tilt (type:float)

                '''
                return MAVLink_evt_tilt_message(tilt)

        def evt_tilt_send(self, tilt, force_mavlink1=False):
                '''
                Tilt angle of robot in the calibrated vertical axis. No need a respond
                message for confimation

                tilt                      : Tilt (type:float)

                '''
                return self.send(self.evt_tilt_encode(tilt), force_mavlink1=force_mavlink1)

        def evt_rpy_encode(self, roll, pitch, yaw):
                '''
                Roll pitch and yaw angle of robot in the earth frame. No need a
                respond message for confimation

                roll                      : Roll (type:float)
                pitch                     : Pitch (type:float)
                yaw                       : Yaw (type:float)

                '''
                return MAVLink_evt_rpy_message(roll, pitch, yaw)

        def evt_rpy_send(self, roll, pitch, yaw, force_mavlink1=False):
                '''
                Roll pitch and yaw angle of robot in the earth frame. No need a
                respond message for confimation

                roll                      : Roll (type:float)
                pitch                     : Pitch (type:float)
                yaw                       : Yaw (type:float)

                '''
                return self.send(self.evt_rpy_encode(roll, pitch, yaw), force_mavlink1=force_mavlink1)

        def evt_sensor_encode(self, imu_status):
                '''
                Report sensor status. No need a respond message for confimation

                imu_status                : IMU status (type:int8_t, values:sensor_t)

                '''
                return MAVLink_evt_sensor_message(imu_status)

        def evt_sensor_send(self, imu_status, force_mavlink1=False):
                '''
                Report sensor status. No need a respond message for confimation

                imu_status                : IMU status (type:int8_t, values:sensor_t)

                '''
                return self.send(self.evt_sensor_encode(imu_status), force_mavlink1=force_mavlink1)

        def motor_speed_encode(self, motor_speed_0, motor_speed_1):
                '''
                Set or info speed for motors. To test the hardware and motor rotaion
                direction. No need a respond message for confimation

                motor_speed_0             : Motor 0 speed (type:int16_t)
                motor_speed_1             : Motor 1 Speed (type:int16_t)

                '''
                return MAVLink_motor_speed_message(motor_speed_0, motor_speed_1)

        def motor_speed_send(self, motor_speed_0, motor_speed_1, force_mavlink1=False):
                '''
                Set or info speed for motors. To test the hardware and motor rotaion
                direction. No need a respond message for confimation

                motor_speed_0             : Motor 0 speed (type:int16_t)
                motor_speed_1             : Motor 1 Speed (type:int16_t)

                '''
                return self.send(self.motor_speed_encode(motor_speed_0, motor_speed_1), force_mavlink1=force_mavlink1)

        def hw_params_encode(self, motor0_invert, motor1_invert, encoder0_invert, encoder1_invert, encoder_exchange, motor0_pos_deadband, motor0_neg_deadband, motor1_pos_deadband, motor1_neg_deadband):
                '''
                Switch to invert motor rotation direction. Need a respond message for
                confimation

                motor0_invert             : Motor 0 Invert (type:int8_t, values:bool_t)
                motor1_invert             : Motor 1 Invert (type:int8_t, values:bool_t)
                encoder0_invert           : Encoder 0 Invert (type:int8_t, values:bool_t)
                encoder1_invert           : Encoder 1 Invert (type:int8_t, values:bool_t)
                encoder_exchange          : Switch to invert encoder from motor 0 to motor 1 and vice versa (type:int8_t, values:bool_t)
                motor0_pos_deadband        : Motor 0 positive deadband (type:int16_t)
                motor0_neg_deadband        : Motor 0 negative deadband (type:int16_t)
                motor1_pos_deadband        : Motor 1 positive deadband (type:int16_t)
                motor1_neg_deadband        : Motor 1 negative deadband (type:int16_t)

                '''
                return MAVLink_hw_params_message(motor0_invert, motor1_invert, encoder0_invert, encoder1_invert, encoder_exchange, motor0_pos_deadband, motor0_neg_deadband, motor1_pos_deadband, motor1_neg_deadband)

        def hw_params_send(self, motor0_invert, motor1_invert, encoder0_invert, encoder1_invert, encoder_exchange, motor0_pos_deadband, motor0_neg_deadband, motor1_pos_deadband, motor1_neg_deadband, force_mavlink1=False):
                '''
                Switch to invert motor rotation direction. Need a respond message for
                confimation

                motor0_invert             : Motor 0 Invert (type:int8_t, values:bool_t)
                motor1_invert             : Motor 1 Invert (type:int8_t, values:bool_t)
                encoder0_invert           : Encoder 0 Invert (type:int8_t, values:bool_t)
                encoder1_invert           : Encoder 1 Invert (type:int8_t, values:bool_t)
                encoder_exchange          : Switch to invert encoder from motor 0 to motor 1 and vice versa (type:int8_t, values:bool_t)
                motor0_pos_deadband        : Motor 0 positive deadband (type:int16_t)
                motor0_neg_deadband        : Motor 0 negative deadband (type:int16_t)
                motor1_pos_deadband        : Motor 1 positive deadband (type:int16_t)
                motor1_neg_deadband        : Motor 1 negative deadband (type:int16_t)

                '''
                return self.send(self.hw_params_encode(motor0_invert, motor1_invert, encoder0_invert, encoder1_invert, encoder_exchange, motor0_pos_deadband, motor0_neg_deadband, motor1_pos_deadband, motor1_neg_deadband), force_mavlink1=force_mavlink1)

        def gyro_params_encode(self, gyro_offset_x, gyro_offset_y, gyro_offset_z):
                '''
                Gyro calibration parameters. No need a respond message for confimation

                gyro_offset_x             : Gyro Offset X (type:float)
                gyro_offset_y             : Gyro Offset Y (type:float)
                gyro_offset_z             : Gyro Offset Z (type:float)

                '''
                return MAVLink_gyro_params_message(gyro_offset_x, gyro_offset_y, gyro_offset_z)

        def gyro_params_send(self, gyro_offset_x, gyro_offset_y, gyro_offset_z, force_mavlink1=False):
                '''
                Gyro calibration parameters. No need a respond message for confimation

                gyro_offset_x             : Gyro Offset X (type:float)
                gyro_offset_y             : Gyro Offset Y (type:float)
                gyro_offset_z             : Gyro Offset Z (type:float)

                '''
                return self.send(self.gyro_params_encode(gyro_offset_x, gyro_offset_y, gyro_offset_z), force_mavlink1=force_mavlink1)

        def comp_filter_params_encode(self, tilt_type, tilt_offset, g_believe):
                '''
                Complimentary filter parameters. No need a respond message for
                confimation

                tilt_type                 : Tilt type (type:uint8_t, values:tilt_type_t)
                tilt_offset               : Tilt angle offset (type:float)
                g_believe                 : Belive in gyroscope (type:float)

                '''
                return MAVLink_comp_filter_params_message(tilt_type, tilt_offset, g_believe)

        def comp_filter_params_send(self, tilt_type, tilt_offset, g_believe, force_mavlink1=False):
                '''
                Complimentary filter parameters. No need a respond message for
                confimation

                tilt_type                 : Tilt type (type:uint8_t, values:tilt_type_t)
                tilt_offset               : Tilt angle offset (type:float)
                g_believe                 : Belive in gyroscope (type:float)

                '''
                return self.send(self.comp_filter_params_encode(tilt_type, tilt_offset, g_believe), force_mavlink1=force_mavlink1)

        def evt_accel_raw_encode(self, acc_x, acc_y, acc_z):
                '''
                IMU raw value. No need a respond message for confimation

                acc_x                     : Accel X (type:float)
                acc_y                     : Accel Y (type:float)
                acc_z                     : Accel Z (type:float)

                '''
                return MAVLink_evt_accel_raw_message(acc_x, acc_y, acc_z)

        def evt_accel_raw_send(self, acc_x, acc_y, acc_z, force_mavlink1=False):
                '''
                IMU raw value. No need a respond message for confimation

                acc_x                     : Accel X (type:float)
                acc_y                     : Accel Y (type:float)
                acc_z                     : Accel Z (type:float)

                '''
                return self.send(self.evt_accel_raw_encode(acc_x, acc_y, acc_z), force_mavlink1=force_mavlink1)

        def evt_gyro_raw_encode(self, gyro_x, gyro_y, gyro_z):
                '''
                IMU raw value. No need a respond message for confimation

                gyro_x                    : Gyro X (type:float)
                gyro_y                    : Gyro Y (type:float)
                gyro_z                    : Gyro Z (type:float)

                '''
                return MAVLink_evt_gyro_raw_message(gyro_x, gyro_y, gyro_z)

        def evt_gyro_raw_send(self, gyro_x, gyro_y, gyro_z, force_mavlink1=False):
                '''
                IMU raw value. No need a respond message for confimation

                gyro_x                    : Gyro X (type:float)
                gyro_y                    : Gyro Y (type:float)
                gyro_z                    : Gyro Z (type:float)

                '''
                return self.send(self.evt_gyro_raw_encode(gyro_x, gyro_y, gyro_z), force_mavlink1=force_mavlink1)

        def evt_calibrated_gyro_raw_encode(self, gyro_x, gyro_y, gyro_z):
                '''
                IMU raw value. No need a respond message for confimation

                gyro_x                    : Gyro X (type:float)
                gyro_y                    : Gyro Y (type:float)
                gyro_z                    : Gyro Z (type:float)

                '''
                return MAVLink_evt_calibrated_gyro_raw_message(gyro_x, gyro_y, gyro_z)

        def evt_calibrated_gyro_raw_send(self, gyro_x, gyro_y, gyro_z, force_mavlink1=False):
                '''
                IMU raw value. No need a respond message for confimation

                gyro_x                    : Gyro X (type:float)
                gyro_y                    : Gyro Y (type:float)
                gyro_z                    : Gyro Z (type:float)

                '''
                return self.send(self.evt_calibrated_gyro_raw_encode(gyro_x, gyro_y, gyro_z), force_mavlink1=force_mavlink1)

        def evt_mag_raw_encode(self, mag_x, mag_y, mag_z):
                '''
                IMU raw value. No need a respond message for confimation

                mag_x                     : Mag X (type:float)
                mag_y                     : Mag Y (type:float)
                mag_z                     : Mag Z (type:float)

                '''
                return MAVLink_evt_mag_raw_message(mag_x, mag_y, mag_z)

        def evt_mag_raw_send(self, mag_x, mag_y, mag_z, force_mavlink1=False):
                '''
                IMU raw value. No need a respond message for confimation

                mag_x                     : Mag X (type:float)
                mag_y                     : Mag Y (type:float)
                mag_z                     : Mag Z (type:float)

                '''
                return self.send(self.evt_mag_raw_encode(mag_x, mag_y, mag_z), force_mavlink1=force_mavlink1)

        def pid_params_encode(self, pid_control, KP, KI, KD):
                '''
                PID Coefficent. No need a respond message for confimation

                pid_control               : Object that PID control (type:uint8_t, values:pidc_t)
                KP                        : KP (type:float)
                KI                        : KI (type:float)
                KD                        : KD (type:float)

                '''
                return MAVLink_pid_params_message(pid_control, KP, KI, KD)

        def pid_params_send(self, pid_control, KP, KI, KD, force_mavlink1=False):
                '''
                PID Coefficent. No need a respond message for confimation

                pid_control               : Object that PID control (type:uint8_t, values:pidc_t)
                KP                        : KP (type:float)
                KI                        : KI (type:float)
                KD                        : KD (type:float)

                '''
                return self.send(self.pid_params_encode(pid_control, KP, KI, KD), force_mavlink1=force_mavlink1)

        def pid_report_encode(self, pid_control, sp, fb, P_Part, I_Part, D_Part, U):
                '''
                Report pid internal parameter

                pid_control               : Object that PID control (type:uint8_t, values:pidc_t)
                sp                        : Set point (type:float)
                fb                        : Feed back (type:float)
                P_Part                    : P part (type:float)
                I_Part                    : I part (type:float)
                D_Part                    : D part (type:float)
                U                         : Output (type:float)

                '''
                return MAVLink_pid_report_message(pid_control, sp, fb, P_Part, I_Part, D_Part, U)

        def pid_report_send(self, pid_control, sp, fb, P_Part, I_Part, D_Part, U, force_mavlink1=False):
                '''
                Report pid internal parameter

                pid_control               : Object that PID control (type:uint8_t, values:pidc_t)
                sp                        : Set point (type:float)
                fb                        : Feed back (type:float)
                P_Part                    : P part (type:float)
                I_Part                    : I part (type:float)
                D_Part                    : D part (type:float)
                U                         : Output (type:float)

                '''
                return self.send(self.pid_report_encode(pid_control, sp, fb, P_Part, I_Part, D_Part, U), force_mavlink1=force_mavlink1)

        def blink_encode(self, uwb_address, role):
                '''
                Location message

                uwb_address               :  (type:uint16_t)
                role                      :  (type:uint8_t, values:role_t)

                '''
                return MAVLink_blink_message(uwb_address, role)

        def blink_send(self, uwb_address, role, force_mavlink1=False):
                '''
                Location message

                uwb_address               :  (type:uint16_t)
                role                      :  (type:uint8_t, values:role_t)

                '''
                return self.send(self.blink_encode(uwb_address, role), force_mavlink1=force_mavlink1)

        def ble_mesh_encode(self, uwb_address, mesh_address):
                '''
                BLE mesh message

                uwb_address               :  (type:uint16_t)
                mesh_address              :  (type:uint16_t)

                '''
                return MAVLink_ble_mesh_message(uwb_address, mesh_address)

        def ble_mesh_send(self, uwb_address, mesh_address, force_mavlink1=False):
                '''
                BLE mesh message

                uwb_address               :  (type:uint16_t)
                mesh_address              :  (type:uint16_t)

                '''
                return self.send(self.ble_mesh_encode(uwb_address, mesh_address), force_mavlink1=force_mavlink1)

        def onoff_encode(self, uwb_address, value):
                '''
                On off message

                uwb_address               :  (type:uint16_t)
                value                     :  (type:uint8_t)

                '''
                return MAVLink_onoff_message(uwb_address, value)

        def onoff_send(self, uwb_address, value, force_mavlink1=False):
                '''
                On off message

                uwb_address               :  (type:uint16_t)
                value                     :  (type:uint8_t)

                '''
                return self.send(self.onoff_encode(uwb_address, value), force_mavlink1=force_mavlink1)

        def location_encode(self, uwb_address, location_x, location_y, location_z):
                '''
                Location message

                uwb_address               :  (type:uint16_t)
                location_x                :  (type:float)
                location_y                :  (type:float)
                location_z                :  (type:float)

                '''
                return MAVLink_location_message(uwb_address, location_x, location_y, location_z)

        def location_send(self, uwb_address, location_x, location_y, location_z, force_mavlink1=False):
                '''
                Location message

                uwb_address               :  (type:uint16_t)
                location_x                :  (type:float)
                location_y                :  (type:float)
                location_z                :  (type:float)

                '''
                return self.send(self.location_encode(uwb_address, location_x, location_y, location_z), force_mavlink1=force_mavlink1)

        def location_reduced_encode(self, mesh_address, location_x, location_y):
                '''
                Location message

                mesh_address              :  (type:uint16_t)
                location_x                :  (type:float)
                location_y                :  (type:float)

                '''
                return MAVLink_location_reduced_message(mesh_address, location_x, location_y)

        def location_reduced_send(self, mesh_address, location_x, location_y, force_mavlink1=False):
                '''
                Location message

                mesh_address              :  (type:uint16_t)
                location_x                :  (type:float)
                location_y                :  (type:float)

                '''
                return self.send(self.location_reduced_encode(mesh_address, location_x, location_y), force_mavlink1=force_mavlink1)

        def distance_encode(self, uwb_address, anchor, distance):
                '''
                Distance message

                uwb_address               :  (type:uint16_t)
                anchor                    :  (type:uint16_t)
                distance                  :  (type:float)

                '''
                return MAVLink_distance_message(uwb_address, anchor, distance)

        def distance_send(self, uwb_address, anchor, distance, force_mavlink1=False):
                '''
                Distance message

                uwb_address               :  (type:uint16_t)
                anchor                    :  (type:uint16_t)
                distance                  :  (type:float)

                '''
                return self.send(self.distance_encode(uwb_address, anchor, distance), force_mavlink1=force_mavlink1)

        def tof_encode(self, uwb_address, anchor, tof):
                '''
                TOF message

                uwb_address               :  (type:uint16_t)
                anchor                    :  (type:uint16_t)
                tof                       :  (type:uint32_t)

                '''
                return MAVLink_tof_message(uwb_address, anchor, tof)

        def tof_send(self, uwb_address, anchor, tof, force_mavlink1=False):
                '''
                TOF message

                uwb_address               :  (type:uint16_t)
                anchor                    :  (type:uint16_t)
                tof                       :  (type:uint32_t)

                '''
                return self.send(self.tof_encode(uwb_address, anchor, tof), force_mavlink1=force_mavlink1)

        def slot_encode(self, uwb_address, slot):
                '''
                Slot message

                uwb_address               :  (type:uint16_t)
                slot                      :  (type:uint8_t)

                '''
                return MAVLink_slot_message(uwb_address, slot)

        def slot_send(self, uwb_address, slot, force_mavlink1=False):
                '''
                Slot message

                uwb_address               :  (type:uint16_t)
                slot                      :  (type:uint8_t)

                '''
                return self.send(self.slot_encode(uwb_address, slot), force_mavlink1=force_mavlink1)

        def tag_encode(self, a0, a0x, a0y, a0z, a0r, a1, a1x, a1y, a1z, a1r, a2, a2x, a2y, a2z, a2r, a3, a3x, a3y, a3z, a3r, t0, t0x, t0y, t0z):
                '''
                Tag message

                a0                        :  (type:uint16_t)
                a0x                       :  (type:float)
                a0y                       :  (type:float)
                a0z                       :  (type:float)
                a0r                       :  (type:float)
                a1                        :  (type:uint16_t)
                a1x                       :  (type:float)
                a1y                       :  (type:float)
                a1z                       :  (type:float)
                a1r                       :  (type:float)
                a2                        :  (type:uint16_t)
                a2x                       :  (type:float)
                a2y                       :  (type:float)
                a2z                       :  (type:float)
                a2r                       :  (type:float)
                a3                        :  (type:uint16_t)
                a3x                       :  (type:float)
                a3y                       :  (type:float)
                a3z                       :  (type:float)
                a3r                       :  (type:float)
                t0                        :  (type:uint16_t)
                t0x                       :  (type:float)
                t0y                       :  (type:float)
                t0z                       :  (type:float)

                '''
                return MAVLink_tag_message(a0, a0x, a0y, a0z, a0r, a1, a1x, a1y, a1z, a1r, a2, a2x, a2y, a2z, a2r, a3, a3x, a3y, a3z, a3r, t0, t0x, t0y, t0z)

        def tag_send(self, a0, a0x, a0y, a0z, a0r, a1, a1x, a1y, a1z, a1r, a2, a2x, a2y, a2z, a2r, a3, a3x, a3y, a3z, a3r, t0, t0x, t0y, t0z, force_mavlink1=False):
                '''
                Tag message

                a0                        :  (type:uint16_t)
                a0x                       :  (type:float)
                a0y                       :  (type:float)
                a0z                       :  (type:float)
                a0r                       :  (type:float)
                a1                        :  (type:uint16_t)
                a1x                       :  (type:float)
                a1y                       :  (type:float)
                a1z                       :  (type:float)
                a1r                       :  (type:float)
                a2                        :  (type:uint16_t)
                a2x                       :  (type:float)
                a2y                       :  (type:float)
                a2z                       :  (type:float)
                a2r                       :  (type:float)
                a3                        :  (type:uint16_t)
                a3x                       :  (type:float)
                a3y                       :  (type:float)
                a3z                       :  (type:float)
                a3r                       :  (type:float)
                t0                        :  (type:uint16_t)
                t0x                       :  (type:float)
                t0y                       :  (type:float)
                t0z                       :  (type:float)

                '''
                return self.send(self.tag_encode(a0, a0x, a0y, a0z, a0r, a1, a1x, a1y, a1z, a1r, a2, a2x, a2y, a2z, a2r, a3, a3x, a3y, a3z, a3r, t0, t0x, t0y, t0z), force_mavlink1=force_mavlink1)

